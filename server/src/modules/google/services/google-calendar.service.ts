import { Injectable, Logger } from '@nestjs/common';
import { google, calendar_v3 } from 'googleapis';
import { GoogleAuthService } from './google-auth.service';
import { Calendar } from '../../calendar/calendar';

@Injectable()
export class GoogleCalendarService {
  private readonly logger = new Logger(GoogleCalendarService.name);

  constructor(private readonly googleAuthService: GoogleAuthService) {}

  private async getCalendarClient(
    userId: string,
  ): Promise<calendar_v3.Calendar | null> {
    const accessToken =
      await this.googleAuthService.getValidAccessToken(userId);

    if (!accessToken) {
      this.logger.warn(`No valid access token for user ${userId}`);
      return null;
    }

    const oauth2Client = this.googleAuthService.getOAuth2Client();
    oauth2Client.setCredentials({ access_token: accessToken });

    return google.calendar({ version: 'v3', auth: oauth2Client });
  }

  async listCalendars(userId: string): Promise<Calendar[]> {
    try {
      const calendar = await this.getCalendarClient(userId);
      if (!calendar) {
        throw new Error('Not connected to Google Calendar');
      }

      const response = await calendar.calendarList.list();

      if (!response.data.items) {
        return [];
      }

      return response.data.items.map((item) => ({
        id: '', // Will be generated by database
        user_id: userId,
        google_calendar_id: item.id || '',
        name: item.summary || undefined,
        description: item.description || undefined,
        timezone: item.timeZone || undefined,
        is_primary: item.primary || false,
        created_at: new Date(),
        updated_at: new Date(),
      }));
    } catch (error) {
      this.logger.error(`Failed to list calendars for user ${userId}:`, error);
      throw new Error('Failed to fetch calendars from Google');
    }
  }

  async getCalendar(
    userId: string,
    calendarId: string,
  ): Promise<calendar_v3.Schema$Calendar | null> {
    try {
      const calendar = await this.getCalendarClient(userId);
      if (!calendar) {
        return null;
      }

      const response = await calendar.calendars.get({ calendarId });
      return response.data;
    } catch (error) {
      this.logger.error(`Failed to get calendar ${calendarId}:`, error);
      return null;
    }
  }

  async listEvents(
    userId: string,
    calendarId: string = 'primary',
    options?: {
      timeMin?: Date;
      timeMax?: Date;
      maxResults?: number;
    },
  ): Promise<calendar_v3.Schema$Event[]> {
    try {
      const calendar = await this.getCalendarClient(userId);
      if (!calendar) {
        throw new Error('Not connected to Google Calendar');
      }

      const response = await calendar.events.list({
        calendarId,
        timeMin: options?.timeMin?.toISOString(),
        timeMax: options?.timeMax?.toISOString(),
        maxResults: options?.maxResults || 100,
        singleEvents: true,
        orderBy: 'startTime',
      });

      return response.data.items || [];
    } catch (error) {
      this.logger.error(`Failed to list events for user ${userId}:`, error);
      throw new Error('Failed to fetch events from Google Calendar');
    }
  }

  async createEvent(
    userId: string,
    calendarId: string = 'primary',
    event: {
      summary: string;
      description?: string;
      start: Date;
      end: Date;
      location?: string;
      source?: {
        title: string;
        url?: string;
      };
      hangoutLink?: string;
    },
  ): Promise<calendar_v3.Schema$Event> {
    try {
      const calendar = await this.getCalendarClient(userId);
      if (!calendar) {
        throw new Error('Not connected to Google Calendar');
      }

      const requestBody: any = {
        summary: event.summary,
        description: event.description,
        location: event.location,
        start: {
          dateTime: event.start.toISOString(),
          timeZone: 'UTC',
        },
        end: {
          dateTime: event.end.toISOString(),
          timeZone: 'UTC',
        },
      };

      if (event.source) {
        requestBody.source = event.source;
      }

      if (event.hangoutLink) {
        requestBody.description = requestBody.description || '';
        if (!requestBody.description.includes(event.hangoutLink)) {
          requestBody.description += `\n\nðŸ”— Meeting Link: ${event.hangoutLink}`;
        }
      }

      const response = await calendar.events.insert({
        calendarId,
        requestBody,
      });

      this.logger.log(`Created event in Google Calendar for user ${userId} with source attribution`);
      return response.data;
    } catch (error) {
      this.logger.error(`Failed to create event for user ${userId}:`, error);
      throw new Error('Failed to create event in Google Calendar');
    }
  }

  async updateEvent(
    userId: string,
    calendarId: string,
    eventId: string,
    event: {
      summary?: string;
      description?: string;
      start?: Date;
      end?: Date;
      location?: string;
      source?: {
        title: string;
        url?: string;
      };
      hangoutLink?: string;
    },
  ): Promise<calendar_v3.Schema$Event> {
    try {
      const calendar = await this.getCalendarClient(userId);
      if (!calendar) {
        throw new Error('Not connected to Google Calendar');
      }

      const updateData: any = {};

      if (event.summary) updateData.summary = event.summary;
      if (event.description) updateData.description = event.description;
      if (event.location) updateData.location = event.location;

      if (event.start) {
        updateData.start = {
          dateTime: event.start.toISOString(),
          timeZone: 'UTC',
        };
      }

      if (event.end) {
        updateData.end = {
          dateTime: event.end.toISOString(),
          timeZone: 'UTC',
        };
      }

      if (event.source) {
        updateData.source = event.source;
      }

      if (event.hangoutLink && updateData.description) {
        if (!updateData.description.includes(event.hangoutLink)) {
          updateData.description += `\n\nðŸ”— Meeting Link: ${event.hangoutLink}`;
        }
      }

      const response = await calendar.events.patch({
        calendarId,
        eventId,
        requestBody: updateData,
      });

      this.logger.log(`Updated event ${eventId} in Google Calendar with source attribution`);
      return response.data;
    } catch (error) {
      this.logger.error(`Failed to update event ${eventId}:`, error);
      throw new Error('Failed to update event in Google Calendar');
    }
  }

  async deleteEvent(
    userId: string,
    calendarId: string,
    eventId: string,
  ): Promise<boolean> {
    try {
      const calendar = await this.getCalendarClient(userId);
      if (!calendar) {
        throw new Error('Not connected to Google Calendar');
      }

      await calendar.events.delete({
        calendarId,
        eventId,
      });

      this.logger.log(`Deleted event ${eventId} from Google Calendar`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to delete event ${eventId}:`, error);
      return false;
    }
  }

  async syncCalendars(
    userId: string,
  ): Promise<{ success: boolean; count: number }> {
    try {
      const calendars = await this.listCalendars(userId);

      this.logger.log(
        `Synced ${calendars.length} calendars for user ${userId}`,
      );

      return {
        success: true,
        count: calendars.length,
      };
    } catch (error) {
      this.logger.error(`Failed to sync calendars for user ${userId}:`, error);
      return {
        success: false,
        count: 0,
      };
    }
  }

  async createGoogleMeet(
    userId: string,
    eventData: {
      summary: string;
      description?: string;
      start_time: string;
      end_time: string;
    },
  ): Promise<{
    url: string;
    id?: string;
    entry_points?: any[];
  } | null> {
    try {
      const calendar = await this.getCalendarClient(userId);
      if (!calendar) {
        throw new Error('Not connected to Google Calendar');
      }

      const response = await calendar.events.insert({
        calendarId: 'primary',
        conferenceDataVersion: 1,
        requestBody: {
          summary: eventData.summary,
          description: eventData.description,
          start: {
            dateTime: eventData.start_time,
            timeZone: 'UTC',
          },
          end: {
            dateTime: eventData.end_time,
            timeZone: 'UTC',
          },
          conferenceData: {
            createRequest: {
              requestId: `meet-${Date.now()}-${Math.random().toString(36).substring(7)}`,
              conferenceSolutionKey: {
                type: 'hangoutsMeet',
              },
            },
          },
        },
      });

      const conferenceData = response.data.conferenceData;
      if (!conferenceData || !conferenceData.entryPoints) {
        this.logger.warn('No conference data returned from Google');
        return null;
      }

      const videoEntry = conferenceData.entryPoints.find(
        (entry) => entry.entryPointType === 'video',
      );

      if (!videoEntry || !videoEntry.uri) {
        this.logger.warn('No video entry point found');
        return null;
      }

      if (response.data.id) {
        await calendar.events.delete({
          calendarId: 'primary',
          eventId: response.data.id,
        });
      }

      this.logger.log(`Created Google Meet link for user ${userId}`);
      return {
        url: videoEntry.uri,
        id: conferenceData.conferenceId || undefined,
        entry_points: conferenceData.entryPoints,
      };
    } catch (error) {
      this.logger.error(
        `Failed to create Google Meet for user ${userId}:`,
        error,
      );
      throw new Error('Failed to create Google Meet link');
    }
  }
}
